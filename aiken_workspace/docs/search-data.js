window.Aiken.initSearch([{"doc":"preprod","title":"beadName","content":"beadName: ByteArray\n","url":"preprod.html#beadName"},{"doc":"preprod","title":"beadPolicyId","content":"beadPolicyId: ByteArray = #&quot;ad035041b7078841cd83bfc715accb6e2c575aa5b6699cd330b45ebf&quot;\n","url":"preprod.html#beadPolicyId"},{"doc":"preprod","title":"beadReferralName","content":"beadReferralName: ByteArray\n","url":"preprod.html#beadReferralName"},{"doc":"preprod","title":"oraclePolicyId","content":"oraclePolicyId: ByteArray = #&quot;039c4f0dde5c22e12cf1d96527a83b4520b8d5e59585784e29ecbade&quot;\n","url":"preprod.html#oraclePolicyId"},{"doc":"preprod","title":"treasury","content":"treasury: ByteArray = #&quot;d5434e727e2b5761e61e8aee4fbdfea3db9b5600a9d989eb7b7fa377&quot;\n","url":"preprod.html#treasury"},{"doc":"preprod","title":"preprod","content":"","url":"preprod.html"},{"doc":"default","title":"beadName","content":"beadName: ByteArray\n","url":"default.html#beadName"},{"doc":"default","title":"beadPolicyId","content":"beadPolicyId: ByteArray = #&quot;88f726eca4f971d876533177b7cd736779d318e528e12aa6942a20eb&quot;\n","url":"default.html#beadPolicyId"},{"doc":"default","title":"beadReferralName","content":"beadReferralName: ByteArray\n","url":"default.html#beadReferralName"},{"doc":"default","title":"oraclePolicyId","content":"oraclePolicyId: ByteArray = #&quot;76ad8c0237016138f33bfd821ffbc3571eb98e6ea11622fd7f014d40&quot;\n","url":"default.html#oraclePolicyId"},{"doc":"default","title":"treasury","content":"treasury: ByteArray = #&quot;d5434e727e2b5761e61e8aee4fbdfea3db9b5600a9d989eb7b7fa377&quot;\n","url":"default.html#treasury"},{"doc":"default","title":"default","content":"","url":"default.html"},{"doc":"preview","title":"beadName","content":"beadName: ByteArray\n","url":"preview.html#beadName"},{"doc":"preview","title":"beadPolicyId","content":"beadPolicyId: ByteArray = #&quot;88f726eca4f971d876533177b7cd736779d318e528e12aa6942a20eb&quot;\n","url":"preview.html#beadPolicyId"},{"doc":"preview","title":"beadReferralName","content":"beadReferralName: ByteArray\n","url":"preview.html#beadReferralName"},{"doc":"preview","title":"oraclePolicyId","content":"oraclePolicyId: ByteArray = #&quot;76ad8c0237016138f33bfd821ffbc3571eb98e6ea11622fd7f014d40&quot;\n","url":"preview.html#oraclePolicyId"},{"doc":"preview","title":"treasury","content":"treasury: ByteArray = #&quot;d5434e727e2b5761e61e8aee4fbdfea3db9b5600a9d989eb7b7fa377&quot;\n","url":"preview.html#treasury"},{"doc":"preview","title":"preview","content":"","url":"preview.html"},{"doc":"util","title":"fixed_point_division","content":"fixed_point_division(valorI: Int, interesI: Int, precision: Int) -&gt; FixedP\n","url":"util.html#fixed_point_division"},{"doc":"util","title":"precision_multiplier","content":"precision_multiplier(precision: Int) -&gt; Int\n","url":"util.html#precision_multiplier"},{"doc":"util","title":"getAdaInOutputsToAddress","content":"getAdaInOutputsToAddress(outputs: List&lt;Output&gt;, address: Address) -&gt; Int\n","url":"util.html#getAdaInOutputsToAddress"},{"doc":"util","title":"getAdaInOutputs","content":"getAdaInOutputs(outputs: List&lt;Output&gt;) -&gt; Int\n","url":"util.html#getAdaInOutputs"},{"doc":"util","title":"compare_token_names","content":"compare_token_names(an: AssetName, tn: Option&lt;ByteArray&gt;) -&gt; Bool\n","url":"util.html#compare_token_names"},{"doc":"util","title":"getTokenInOutputsBurned","content":"getTokenInOutputsBurned(\n  outputs: List&lt;Output&gt;,\n  policyId: PolicyId,\n  assetName: AssetName,\n) -&gt; Int\n","url":"util.html#getTokenInOutputsBurned"},{"doc":"util","title":"getTokenInOutputs","content":"getTokenInOutputs(\n  outputs: List&lt;Output&gt;,\n  policyId: PolicyId,\n  assetName: AssetName,\n  address: Address,\n) -&gt; Int\n","url":"util.html#getTokenInOutputs"},{"doc":"util","title":"signed_by","content":"signed_by(signer: ByteArray, signatories: List&lt;ByteArray&gt;) -&gt; Bool\n","url":"util.html#signed_by"},{"doc":"util","title":"signer","content":"signer(signatories: List&lt;ByteArray&gt;) -&gt; ByteArray\n","url":"util.html#signer"},{"doc":"util","title":"payedToAddress","content":"payedToAddress(self: Transaction, address: Address) -&gt; Int\n","url":"util.html#payedToAddress"},{"doc":"util","title":"value_sent_to_pubkeyhash","content":"value_sent_to_pubkeyhash(\n  tx: Transaction,\n  pubkeyhash: VerificationKeyHash,\n) -&gt; Value\n","url":"util.html#value_sent_to_pubkeyhash"},{"doc":"util","title":"address_from_tuple","content":"address_from_tuple(key_hash_tuple: (PaymentKeyHash, StakeKeyHash)) -&gt; Address\n","url":"util.html#address_from_tuple"},{"doc":"util","title":"util","content":" calculate winnings : total wining bet, total ada in pot, my winning tickets","url":"util.html"},{"doc":"bead","title":"getReferralBeadFromReference","content":"getReferralBeadFromReference(\n  refs: List&lt;Output&gt;,\n  policyId: PolicyId,\n  assetName: AssetName,\n) -&gt; Int\n Calculate the total BEAD tokens present in reference outputs for referral rewards\n \n This function examines all reference outputs to determine how many BEAD referral\n tokens are available for calculation purposes. It&#39;s used to cap referral rewards\n based on the available referral token supply.\n \n Parameters:\n - refs: List of reference outputs to examine\n - policyId: The policy ID of the BEAD token\n - assetName: The asset name for BEAD referral tokens\n \n Returns:\n - Int: Total quantity of BEAD referral tokens found in references\n \n Logic:\n 1. Extract token quantities from each reference output\n 2. Sum all quantities to get total available referral tokens\n 3. Return total for use in referral cap calculations\n \n Used For:\n - Calculating maximum possible referral rewards\n - Ensuring referral rewards don&#39;t exceed available supply\n - Transparent referral token accounting","url":"bead.html#getReferralBeadFromReference"},{"doc":"bead","title":"maxReferral","content":"maxReferral(ref: Int) -&gt; Int\n Apply maximum cap to referral rewards\n \n Ensures referral rewards don&#39;t exceed the protocol&#39;s maximum limit of 50 tokens.\n This prevents excessive referral rewards that could destabilize the token economy.\n \n Parameters:\n - ref: The calculated referral amount before capping\n \n Returns:\n - Int: The capped referral amount (maximum 50)\n \n Business Logic:\n - Maximum referral reward: 50 BEAD tokens\n - Prevents referral reward inflation\n - Maintains sustainable token economics\n - Protects against excessive referral claims\n \n Example:\n ```\n maxReferral(25) -&gt; 25  // No capping needed\n maxReferral(75) -&gt; 50  // Capped to maximum\n ```","url":"bead.html#maxReferral"},{"doc":"bead","title":"verifyRatios","content":"verifyRatios(treasuryAda: Int, referralAda: Int, ratio: Int) -&gt; Bool\n Verify that referral payment ratios are correct\n \n Validates that the referral payment amount matches the expected percentage\n of the total ADA payment (treasury + referral). This ensures the referral\n system maintains proper economic ratios.\n \n Parameters:\n - treasuryAda: Amount of ADA paid to treasury\n - referralAda: Amount of ADA paid to referrer\n - ratio: Expected referral percentage (0-100)\n \n Returns:\n - Bool: True if the referral ratio is correct, False otherwise\n \n Calculation:\n 1. Calculate total ADA: treasury + referral\n 2. Calculate expected referral: total * ratio / 100\n 3. Verify expected equals actual referral payment\n \n Example:\n ```\n verifyRatios(180_000_000, 20_000_000, 10) -&gt; True\n // 200M total * 10% = 20M referral (correct)\n \n verifyRatios(190_000_000, 10_000_000, 10) -&gt; False\n // 200M total * 10% = 20M, but only 10M paid (incorrect)\n ```","url":"bead.html#verifyRatios"},{"doc":"bead","title":"calcBead","content":"calcBead(input: Int) -&gt; Int\n Calculate BEAD tokens to mint based on ADA payment\n \n Converts ADA payment amounts to corresponding BEAD token quantities using\n predefined conversion rates. Supports both fixed-rate tiers and a fallback\n formula for custom amounts.\n \n Parameters:\n - input: ADA amount in lovelace (1 ADA = 1,000,000 lovelace)\n \n Returns:\n - Int: Number of BEAD tokens to mint\n \n Conversion Tiers:\n - 200 ADA (200M lovelace) -&gt; 1,000 BEAD\n - 400 ADA (400M lovelace) -&gt; 2,040 BEAD\n - 600 ADA (600M lovelace) -&gt; 3,090 BEAD\n - 800 ADA (800M lovelace) -&gt; 4,060 BEAD\n - 1,000 ADA (1B lovelace) -&gt; 5,250 BEAD\n - 2,000 ADA (2B lovelace) -&gt; 10,500 BEAD\n - Other amounts: input * 5 / 100,000 (custom formula)\n \n Example:\n ```\n calcBead(200_000_000) -&gt; 1000    // 200 ADA -&gt; 1000 BEAD\n calcBead(150_000_000) -&gt; 7500    // 150 ADA -&gt; 7500 BEAD (formula)\n ```","url":"bead.html#calcBead"},{"doc":"bead","title":"calcBeadReferral","content":"calcBeadReferral(input: Int) -&gt; Int\n Calculate BEAD referral tokens based on total ADA payment\n \n Determines the number of BEAD referral tokens to mint based on the total\n ADA payment (treasury + referral). Referral tokens are bonus rewards for\n successful referrals in the BEAD ecosystem.\n \n Parameters:\n - input: Total ADA amount in lovelace (treasury + referral payments)\n \n Returns:\n - Int: Number of BEAD referral tokens to mint\n \n Referral Reward Tiers:\n - 200 ADA total -&gt; 5 BEAD referral tokens\n - 400 ADA total -&gt; 10 BEAD referral tokens\n - 600 ADA total -&gt; 15 BEAD referral tokens\n - 800 ADA total -&gt; 20 BEAD referral tokens\n - 1,000 ADA total -&gt; 25 BEAD referral tokens\n - 2,000 ADA total -&gt; 50 BEAD referral tokens\n - Other amounts -&gt; 0 (no referral reward for non-standard amounts)\n \n Business Logic:\n - Referral rewards are only given for specific payment tiers\n - Maximum referral reward is 50 tokens (enforced by maxReferral function)\n - Non-standard amounts receive no referral rewards\n \n Example:\n ```\n calcBeadReferral(200_000_000) -&gt; 5     // 200 ADA -&gt; 5 referral tokens\n calcBeadReferral(150_000_000) -&gt; 0     // Custom amount -&gt; no referral\n ```","url":"bead.html#calcBeadReferral"},{"doc":"bead","title":"validatePayedAndMintedBead","content":"validatePayedAndMintedBead(mintedBeadQt: Int, paiedToTreasury: Int) -&gt; Bool\n","url":"bead.html#validatePayedAndMintedBead"},{"doc":"bead","title":"validatePayedAndMintedBeadReferral","content":"validatePayedAndMintedBeadReferral(\n  mintedBeadReferralQt: Int,\n  paiedToTreasury: Int,\n) -&gt; Bool\n","url":"bead.html#validatePayedAndMintedBeadReferral"},{"doc":"bead","title":"BeadRedeemer","content":"BeadRedeemer {\n  action: Int,\n}\n BEAD Protocol - Token Minting Validator\n =====================================\n \n This validator handles the minting of BEAD tokens with an integrated referral system.\n BEAD tokens are the core utility tokens in the BEAD protocol, used for betting,\n oracle operations, and referral rewards.\n \n Features:\n - Controlled token minting with treasury authorization\n - Integrated referral system with configurable reward ratios\n - Treasury payment validation for each mint operation\n - Proper token burning validation\n \n Architecture:\n - Action-based redeemer system (mint=0, burn=1, other=2+)\n - Referral rewards paid as additional BEAD tokens\n - Treasury fees collected for each mint operation\n - Uses shared validation library for common patterns\n \n Token Economics:\n - Treasury receives payment for each mint operation\n - Referrers receive bonus BEAD tokens as rewards\n - Controlled supply through treasury authorization\n \n Example Usage:\n - Mint 1000 BEAD with referrer: mint 1000 to user + bonus to referrer\n - Burn operation: reduce total supply by specified amount\n - Treasury operations: controlled by treasury signature\n BeadRedeemer type defines the action to be performed by the validator\n \n Actions:\n - 0: Mint BEAD tokens (with optional referral rewards)\n - 1: Burn BEAD tokens (reduce total supply)\n - 2+: Future actions (reserved for protocol upgrades)\nBeadRedeemer { action: Int }\n","url":"bead.html#BeadRedeemer"},{"doc":"bead","title":"bead","content":"","url":"bead.html"},{"doc":"validation","title":"validate_treasury_signature","content":"validate_treasury_signature(\n  extra_signatories: List&lt;ByteArray&gt;,\n  context: ByteArray,\n) -&gt; Bool\n Validates that a transaction is signed by the treasury wallet\n \n This function checks if the treasury&#39;s signature is present in the transaction&#39;s\n extra signatories list. Used across all validators to ensure treasury authorization\n for minting operations and administrative actions.\n\n ## Parameters\n - `extra_signatories`: List of public key hashes that signed the transaction\n - `context`: Identifying string for debugging (e.g., &quot;bead-mint-treasury&quot;)\n\n ## Returns\n - `Bool`: True if treasury signature is valid, False otherwise\n\n ## Tracing Output\n - Validation context identifier\n - Success/failure status with ✓/✗ indicators\n - Structured debug sections for easy log parsing\n\n ## Example Usage\n ```aiken\n validation.validate_treasury_signature(\n   extra_signatories: self.extra_signatories,\n   context: &quot;bead-mint-treasury&quot;,\n )\n ```","url":"validation.html#validate_treasury_signature"},{"doc":"validation","title":"validate_timing_after","content":"validate_timing_after(\n  range: ValidityRange,\n  target_time: POSIXTime,\n  context: ByteArray,\n) -&gt; Bool\n Validates that a transaction must start after a specific time\n \n Ensures that the transaction&#39;s validity range starts after the specified target time.\n Commonly used in betting scenarios to verify game completion timing or payout windows.\n\n ## Parameters\n - `range`: Transaction validity range containing time bounds\n - `target_time`: Minimum required start time (POSIXTime in milliseconds)\n - `context`: Identifying string for debugging (e.g., &quot;bet-spend-claim&quot;)\n\n ## Returns\n - `Bool`: True if transaction starts after target time, False otherwise\n\n ## Validation Logic\n - Checks if transaction has a finite lower bound\n - Compares transaction start time with target time\n - Fails if transaction could start before the target time\n\n ## Example Usage\n ```aiken\n validation.validate_timing_after(\n   range: self.validity_range,\n   target_time: gameDate,\n   context: &quot;bet-spend-claim&quot;,\n )\n ```","url":"validation.html#validate_timing_after"},{"doc":"validation","title":"validate_timing_before","content":"validate_timing_before(\n  range: ValidityRange,\n  target_time: POSIXTime,\n  context: ByteArray,\n) -&gt; Bool\n Validates that a transaction must start before a specific time\n \n Ensures that the transaction&#39;s validity range starts before the specified target time.\n Commonly used to enforce betting windows or time-limited operations.\n\n ## Parameters\n - `range`: Transaction validity range containing time bounds\n - `target_time`: Maximum allowed start time (POSIXTime in milliseconds)\n - `context`: Identifying string for debugging (e.g., &quot;bet-mint&quot;)\n\n ## Returns\n - `Bool`: True if transaction starts before target time, False otherwise\n\n ## Validation Logic\n - Checks if transaction has a finite upper bound\n - Compares transaction end time with target time\n - Fails if transaction could run past the target time\n\n ## Example Usage\n ```aiken\n validation.validate_timing_before(\n   range: self.validity_range,\n   target_time: gameDate,\n   context: &quot;bet-mint&quot;,\n )\n ```","url":"validation.html#validate_timing_before"},{"doc":"validation","title":"validate_token_burn","content":"validate_token_burn(\n  tx: Transaction,\n  policy_id: PolicyId,\n  asset_name: AssetName,\n  context: ByteArray,\n) -&gt; Bool\n Validates token burning operations (negative quantity in mint field)\n \n Ensures that a specific token is being burned (has negative quantity) in the transaction.\n Used for token redemption, bet claiming, and cleanup operations.\n\n ## Parameters\n - `tx`: Transaction containing the mint field to validate\n - `policy_id`: Policy ID of the token being burned\n - `asset_name`: Asset name of the specific token being burned\n - `context`: Identifying string for debugging (e.g., &quot;bet-mint-burn&quot;)\n\n ## Returns\n - `Bool`: True if token quantity is negative (burning), False otherwise\n\n ## Validation Logic\n - Extracts token quantity from transaction mint field\n - Verifies quantity is negative (indicates burning)\n - Logs actual quantity for debugging\n\n ## Example Usage\n ```aiken\n validation.validate_token_burn(\n   tx: self,\n   policy_id: policy_id,\n   asset_name: betAssetName,\n   context: &quot;bet-mint-burn&quot;,\n )\n ```","url":"validation.html#validate_token_burn"},{"doc":"validation","title":"validate_token_quantity_exact","content":"validate_token_quantity_exact(\n  actual: Int,\n  expected: Int,\n  token_name: ByteArray,\n  context: ByteArray,\n) -&gt; Bool\n Validates exact token quantity matching\n \n Ensures that two integer quantities match exactly. Used for validating calculated\n vs actual token amounts, game ID verification, and precise quantity checks.\n\n ## Parameters\n - `actual`: The actual quantity found in the transaction\n - `expected`: The expected quantity based on calculations or rules\n - `token_name`: Human-readable token identifier for debugging\n - `context`: Identifying string for debugging (e.g., &quot;bead-mint-referral&quot;)\n\n ## Returns\n - `Bool`: True if actual equals expected, False otherwise\n\n ## Validation Logic\n - Performs exact equality comparison (actual == expected)\n - Logs both values for debugging mismatches\n - Provides clear success/failure indicators\n\n ## Example Usage\n ```aiken\n validation.validate_token_quantity_exact(\n   actual: mintedBeadQt,\n   expected: calcBead(totalAda),\n   token_name: &quot;BEAD&quot;,\n   context: &quot;bead-mint-referral&quot;,\n )\n ```","url":"validation.html#validate_token_quantity_exact"},{"doc":"validation","title":"validate_ada_balance","content":"validate_ada_balance(\n  total_inputs: Int,\n  payout: Int,\n  total_outputs: Int,\n  context: ByteArray,\n) -&gt; Bool\n Validates ADA balance equation for payout calculations\n \n Ensures that ADA inputs minus payouts equal ADA outputs, maintaining balance\n in the betting system. Critical for preventing ADA drain attacks.\n\n ## Parameters\n - `total_inputs`: Total ADA amount in validator inputs (lovelaces)\n - `payout`: ADA amount being paid out to winners (lovelaces)  \n - `total_outputs`: Total ADA amount in validator outputs (lovelaces)\n - `context`: Identifying string for debugging (e.g., &quot;bet-spend-claim&quot;)\n\n ## Returns\n - `Bool`: True if balance equation holds, False otherwise\n\n ## Validation Logic\n - Calculates: total_inputs - payout\n - Compares with: total_outputs\n - Equation must hold: inputs - payout = outputs\n - Prevents over-payment and ADA drainage\n\n ## Example Usage\n ```aiken\n validation.validate_ada_balance(\n   total_inputs: allOwnAdaInInputs,\n   payout: payout,\n   total_outputs: allOwnAdaInOutputs,\n   context: &quot;bet-spend-claim&quot;,\n )\n ```","url":"validation.html#validate_ada_balance"},{"doc":"validation","title":"trace_with_context","content":"trace_with_context(label: ByteArray, value: Data, context: ByteArray) -&gt; Void\n Enhanced trace with context information","url":"validation.html#trace_with_context"},{"doc":"validation","title":"trace_calculation","content":"trace_calculation(\n  operation: ByteArray,\n  inputs: List&lt;(ByteArray, Data)&gt;,\n  result: Data,\n  context: ByteArray,\n) -&gt; Void\n Trace calculation steps for better debugging","url":"validation.html#trace_calculation"},{"doc":"validation","title":"get_outputs_by_credential","content":"get_outputs_by_credential(\n  outputs: List&lt;Output&gt;,\n  credential: PaymentCredential,\n) -&gt; List&lt;Output&gt;\n Filters outputs by payment credential\n \n Returns all transaction outputs that belong to a specific payment credential.\n Used for calculating validator-specific ADA amounts in multi-validator transactions.\n\n ## Parameters\n - `outputs`: List of all transaction outputs\n - `credential`: Payment credential to filter by\n\n ## Returns\n - `List&lt;Output&gt;`: Filtered list containing only matching outputs\n\n ## Use Cases\n - Calculating total ADA in validator outputs\n - Filtering payout destinations\n - Validator-specific balance calculations","url":"validation.html#get_outputs_by_credential"},{"doc":"validation","title":"get_inputs_by_credential","content":"get_inputs_by_credential(\n  inputs: List&lt;Input&gt;,\n  credential: PaymentCredential,\n) -&gt; List&lt;Output&gt;\n Filters inputs by payment credential and extracts their outputs\n \n Returns outputs from all transaction inputs that belong to a specific payment credential.\n Used for calculating validator-specific input ADA amounts.\n\n ## Parameters\n - `inputs`: List of all transaction inputs\n - `credential`: Payment credential to filter by\n\n ## Returns\n - `List&lt;Output&gt;`: List of outputs from matching inputs\n\n ## Processing Steps\n 1. Extract output from each input\n 2. Filter by payment credential match\n 3. Return filtered output list\n\n ## Use Cases\n - Calculating total ADA in validator inputs\n - Input validation and verification\n - Balance calculations for payouts","url":"validation.html#get_inputs_by_credential"},{"doc":"validation","title":"validation","content":"\n BEAD Protocol - Common Validation Library\n\n This module provides centralized validation functions used across all BEAD protocol validators.\n It implements common patterns for treasury validation, timing checks, token operations,\n and ADA balance verification with enhanced tracing for debugging.\n\n Key Features:\n - Standardized validation patterns across all validators\n - Enhanced tracing with structured debug output  \n - Reusable utility functions for input/output filtering\n - Consistent error handling and success indicators\n\n Validators using this library:\n - bead.ak: BEAD token minting with referral system\n - bet.ak: Betting validator with complex payout calculations\n - oracle.ak: Oracle token minting for game results\n","url":"validation.html"},{"doc":"types","title":"BetAction","content":"BetAction {\n  action: Int,\n}\n\nBetAction { action: Int }\n","url":"types.html#BetAction"},{"doc":"types","title":"BetDatum","content":"BetDatum {\n  winner: Int,\n  betPolicyId: ByteArray,\n  playerPkh: ByteArray,\n}\n\nBetDatum { winner: Int, betPolicyId: ByteArray, playerPkh: ByteArray }\n","url":"types.html#BetDatum"},{"doc":"types","title":"BetMintingRedeemer","content":"BetMintingRedeemer {\n  result: Int,\n  action: Int,\n}\n\nBetMintingRedeemer { result: Int, action: Int }\n","url":"types.html#BetMintingRedeemer"},{"doc":"types","title":"FixedP","content":"FixedP = Pair&lt;Int, Int&gt;\n\n","url":"types.html#FixedP"},{"doc":"types","title":"OracleDatum","content":"OracleDatum {\n  gameId: Int,\n  winner: Int,\n  betPolicyId: ByteArray,\n  totalAda: Int,\n  totalWinning: Int,\n}\n\nOracleDatum {\n  gameId: Int,\n  winner: Int,\n  betPolicyId: ByteArray,\n  totalAda: Int,\n  totalWinning: Int,\n}\n","url":"types.html#OracleDatum"},{"doc":"types","title":"POSIXTime","content":"POSIXTime = Int\n\n","url":"types.html#POSIXTime"},{"doc":"types","title":"PaymentKeyHash","content":"PaymentKeyHash = VerificationKeyHash\n\n","url":"types.html#PaymentKeyHash"},{"doc":"types","title":"StakeKeyHash","content":"StakeKeyHash = VerificationKeyHash\n\n","url":"types.html#StakeKeyHash"},{"doc":"types","title":"types","content":"","url":"types.html"},{"doc":"bet","title":"calculate_expected_bet_quantity","content":"calculate_expected_bet_quantity(paid_to_pot: Int, bead_qt: Int) -&gt; Int\n Calculate the expected bet quantity based on ADA paid and BEAD tokens","url":"bet.html#calculate_expected_bet_quantity"},{"doc":"bet","title":"calculate_payout","content":"calculate_payout(bet_qt: Int, total_winnings: Int, total_ada: Int) -&gt; Int\n Calculate payout for winning bet\n \n This function implements the core payout calculation with specific rounding behavior.\n It uses rational arithmetic to ensure precise calculations and then applies floor \n rounding to determine the final payout amount.\n\n Parameters:\n - bet_qt: The quantity of bet tokens being burned (negative value, e.g., -10000000)\n - total_winnings: Total amount of winning bet tokens across all winners (positive, e.g., 17000000)\n - total_ada: Total ADA available in the prize pool (positive, e.g., 32000000 lovelace)\n\n Formula: payout = floor((-bet_qt / total_winnings) × total_ada)\n\n Example calculation:\n - bet_qt = -10000000 (Account A&#39;s bet tokens, negative because burning)\n - total_winnings = 17000000 (Account A: 10M + Account C: 7M tokens)\n - total_ada = 32000000 (10 + 15 + 7 = 32 ADA in lovelace)\n\n Step 1: Create ratio of bet tokens to total winnings\n   ratio = (-(-10000000)) / 17000000 = 10000000 / 17000000 = 0.588235294...\n\n Step 2: Multiply by total ADA available\n   payout_exact = 0.588235294... × 32000000 = 18823529.411764705...\n\n Step 3: Apply floor rounding (CRITICAL FOR PREVENTING INSUFFICIENT FUNDS)\n   payout_final = floor(18823529.411764705...) = 18823529 lovelace\n\n ROUNDING BEHAVIOR:\n The use of rational.floor() means ANY fractional part rounds DOWN to the lower integer.\n This prevents claiming more than available in the pot:\n - 18823529.1 → 18823529 (rounds down)\n - 18823529.9 → 18823529 (rounds down) \n - 18823529.0 → 18823529 (no change, already integer)\n\n OFF-CHAIN MATCHING:\n The off-chain code MUST use identical logic to avoid validation failures.\n JavaScript Math.floor() should match this behavior exactly.\n\n INSUFFICIENT FUNDS PREVENTION:\n Floor rounding ensures we never try to claim more than what&#39;s available in the pot.\n Better to leave a few lovelaces in the pot than to have redemptions fail.\n Calculates precise payout using rational arithmetic with floor rounding\n\n Implements the core payout formula: (bet_tokens / total_winnings) × total_ada\n Uses rational arithmetic to prevent floating-point errors and applies floor\n rounding to ensure sequential redemptions don&#39;t fail due to rounding accumulation.\n\n ## Parameters\n - `bet_qt`: Quantity of betting tokens being burned (negative value)\n - `total_winnings`: Total winning betting tokens for this result\n - `total_ada`: Total ADA available for distribution\n\n ## Returns\n - `Int`: Calculated payout amount in lovelaces (ADA)\n\n ## Calculation Steps\n 1. Convert bet quantity to positive ratio component (-bet_qt / total_winnings)\n 2. Create rational representation of total ADA pool\n 3. Multiply ratios for proportional payout calculation\n 4. Apply floor rounding to prevent over-payment\n\n ## Floor Rounding Benefits\n - Prevents sequential redemption failures\n - Ensures total payouts never exceed available ADA\n - Maintains system integrity under high concurrent redemptions\n\n ## Example\n - Bet: 100 tokens, Total Winnings: 500 tokens, Total ADA: 1000 ADA\n - Calculation: (100/500) × 1000 = 200 ADA payout","url":"bet.html#calculate_payout"},{"doc":"bet","title":"datum_of","content":"datum_of(output: Output) -&gt; Option&lt;Data&gt;\n Extracts inline datum from transaction output\n\n Helper function to safely extract inline datums from UTxOs, commonly used\n for oracle data validation and result verification.\n\n ## Parameters\n - `output`: Transaction output that may contain an inline datum\n\n ## Returns\n - `Option&lt;Data&gt;`: Some(datum) if inline datum exists, None otherwise\n\n ## Use Cases\n - Oracle result extraction\n - Datum validation in multi-validator transactions\n - Safe datum parsing with error handling","url":"bet.html#datum_of"},{"doc":"bet","title":"lessThanHaft","content":"lessThanHaft(lovelaces: Int, bead: Int) -&gt; Bool\n BEAD token spam prevention validation (Half Test)\n\n Ensures sufficient ADA is provided relative to BEAD token quantities to prevent\n micro-betting spam attacks. Requires at least 2 ADA per BEAD token involved.\n\n ## Parameters\n - `lovelaces`: ADA amount in the transaction (in lovelaces)\n - `bead`: BEAD token quantity involved in the transaction\n\n ## Returns\n - `Bool`: True if ADA/BEAD ratio is acceptable, False if spam detected\n\n ## Validation Rules\n - BEAD &gt; 0: Requires lovelaces/(bead × 1M) &gt;= 2 (minimum 2 ADA per BEAD)\n - BEAD = 0: Allows any positive ADA amount (no BEAD tokens involved)\n - BEAD &lt; 0: Prevents negative token exploits (should not occur in normal flow)\n\n ## Spam Prevention\n - Prevents micro-transactions that could clog the network\n - Ensures meaningful betting amounts relative to transaction fees\n - Maintains economic viability of betting operations","url":"bet.html#lessThanHaft"},{"doc":"bet","title":"checkGameResultCorrect","content":"checkGameResultCorrect(\n  gameNameBA: ByteArray,\n  gameResultBA: ByteArray,\n  gameResult: Int,\n) -&gt; Bool\n Validates that the provided game result ByteArray matches the expected format\n of result concatenated with game name","url":"bet.html#checkGameResultCorrect"},{"doc":"bet","title":"getResultBA","content":"getResultBA(gameNameBA: ByteArray, gameResult: Int) -&gt; ByteArray\n Generates the expected token name by concatenating the game result with the game name","url":"bet.html#getResultBA"},{"doc":"bet","title":"bet","content":"\n BEAD Protocol - Betting Validator\n\n This validator manages the betting system for sports games, handling both betting token\n minting/burning and payout distribution. It implements complex rational arithmetic for\n precise payout calculations and integrates with oracle validators for game results.\n\n Key Features:\n - Time-based betting windows (bet before game, claim after game)\n - Rational arithmetic for precise payout calculations with floor rounding\n - Oracle integration for verified game results\n - BEAD token integration for betting fees\n - Treasury signature validation for administrative actions\n - Enhanced tracing for debugging complex payout logic\n\n Validator Parameters:\n - gameId: Unique integer identifier for the specific game\n - gameName: Human-readable game name (e.g., &quot;Porto&quot;)\n - gameDate: POSIX timestamp when game completes and payouts become available\n\n Supported Actions:\n 1. Mint: Create betting tokens during betting window (before gameDate)\n 2. Spend: Claim winnings using betting tokens (after gameDate)\n 3. Treasury: Administrative token burning with treasury signature\n","url":"bet.html"}]);